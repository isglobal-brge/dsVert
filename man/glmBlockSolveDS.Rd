% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glmEncryptedDS.R
\name{glmBlockSolveDS}
\alias{glmBlockSolveDS}
\title{Solve BCD block update given decrypted gradient (non-label server)}
\usage{
glmBlockSolveDS(
  data_name,
  x_vars,
  w,
  beta_current,
  gradient,
  lambda = 1e-04,
  session_id = NULL
)
}
\arguments{
\item{data_name}{Character. Name of data frame with local features
(typically the standardized version).}

\item{x_vars}{Character vector. Feature column names on this server.}

\item{w}{Numeric vector. IRLS weights (length n), broadcast by client.
Family-dependent: gaussian=1, binomial=mu*(1-mu), poisson=mu.}

\item{beta_current}{Numeric vector. Current coefficients (length p_k).}

\item{gradient}{Numeric vector. Decrypted gradient g_k (length p_k)
from threshold decryption.}

\item{lambda}{Numeric. L2 regularization parameter. Default 1e-4.
Prevents singular Hessian and adds mild shrinkage.}

\item{session_id}{Character or NULL. UUID for session-scoped storage
isolation. Default NULL uses legacy shared storage.}
}
\value{
List with:
\itemize{
\item \code{beta}: Updated coefficient vector (length p_k)
\item \code{eta}: Linear predictor contribution X_k * beta_new (length n)
\item \code{converged}: TRUE unless extreme update scaling was needed
}
}
\description{
After threshold decryption reveals the p_k-length gradient g_k, this
function performs the Block Coordinate Descent update for the non-label
server's coefficient block. The update formula is:
}
\details{
\deqn{\beta_k^{new} = (X_k^T W X_k + \lambda I)^{-1} (X_k^T W X_k \beta_k^{old} + g_k)}

This is a Newton-Raphson step where X_k^T W X_k is the local Hessian
approximation and g_k is the gradient from the encrypted protocol.
The L2 penalty lambda*I ensures the Hessian is positive definite.
}
