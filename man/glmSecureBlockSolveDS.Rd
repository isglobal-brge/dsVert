% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glmSecureRouting.R
\name{glmSecureBlockSolveDS}
\alias{glmSecureBlockSolveDS}
\title{BCD block update with transport-encrypted eta output}
\usage{
glmSecureBlockSolveDS(
  data_name,
  x_vars,
  encrypted_mwv = NULL,
  beta_current,
  gradient,
  lambda = 1e-04,
  coordinator_pk = NULL
)
}
\arguments{
\item{data_name}{Character. Name of the data frame with local features.}

\item{x_vars}{Character vector. Feature column names on this server.}

\item{encrypted_mwv}{Character or NULL. Transport-encrypted (mu, w, v) blob
(base64url). If NULL, reads from blob storage under key \code{"mwv"}
(set via \code{\link{mheStoreBlobDS}}).}

\item{beta_current}{Numeric vector. Current coefficients for this block.}

\item{gradient}{Numeric vector. Decrypted gradient from threshold decryption
(p_k scalars).}

\item{lambda}{Numeric. L2 regularization parameter. Default 1e-4.}

\item{coordinator_pk}{Character or NULL. Coordinator's transport PK
(base64url). If NULL, reads from stored peer transport PKs.}
}
\value{
List with:
\itemize{
\item \code{beta}: Updated coefficient vector (p_k-length, safe aggregate)
\item \code{encrypted_eta}: Transport-encrypted \eqn{eta_k = X_k \cdot beta_k}
(base64url, opaque to client)
}
}
\description{
Non-label server function for the secure routing protocol. After threshold
decryption reveals the p_k-length gradient, this function:
\enumerate{
\item Decrypts (mu, w, v) from the coordinator's blob to get IRLS weights
\item Solves the BCD block update: \eqn{beta = (X_k^T W X_k + \lambda I)^{-1}
    (X_k^T W X_k \cdot beta_{old} + gradient)} (same math as
\code{\link{glmBlockSolveDS}})
\item Computes \eqn{eta_k = X_k \cdot beta_k} and encrypts it under the
coordinator's transport PK
}
}
\details{
The client receives only beta (p_k-length, safe) and an opaque encrypted
eta blob that it relays to the coordinator on the next iteration.
}
\seealso{
\code{\link{glmSecureGradientDS}}, \code{\link{glmCoordinatorStepDS}}
}
